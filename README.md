# TradingBot - Quantitative Crypto Trading System

A sophisticated Python trading bot implementing advanced quantitative strategies for cryptocurrency markets. The system is designed around the fundamental expected returns formula:

## **E[r] = α + sharpe × risk**

This formula captures the essence of our approach:
- **α (Alpha)**: Excess returns from signal generation strategies
- **sharpe**: Risk-adjusted return efficiency
- **risk**: Dynamic position sizing and risk management

---

## Table of Contents

- [Strategy Overview](#strategy-overview)
- [1. Strategies for Creating α (Alpha)](#1-strategies-for-creating-α-alpha)
- [2. Sharpe Maximization](#2-sharpe-maximization)
  - [Portfolio Optimization (Tangency Portfolio)](#25-portfolio-optimization-tangency-portfolio-minimum-variance-frontier)
  - [Machine Learning Pattern Recognition](#26-machine-learning-pattern-recognition)
- [3. Risk Management](#3-risk-management)
- [Installation & Usage](#installation--usage)
- [Architecture](#architecture)

---

## Strategy Overview

Our trading system employs a multi-strategy approach combining **trend-following**, **breakout detection**, and **mean reversion** techniques. Each component is optimized to maximize the expected return formula **E[r] = α + sharpe × risk**.

### Core Strategies

| Strategy | Type | Primary Indicators | Timeframe |
|----------|------|-------------------|-----------|
| **Enhanced Breakout** | Trend-following | Multi-timeframe trends, volume, support/resistance | 1h-24h |
| **Volatility Expansion** | Breakout | Bollinger squeeze, RSI, MACD | 4h-daily |
| **Mean Reversion** | Counter-trend | RSI divergence, Bollinger bands, ADX, ML patterns | 4h |
| **Sharpe Optimized** | Momentum | Rolling Sharpe ratio, momentum | 3-day window |
| **Tangency Portfolio** | Portfolio optimization | MPT, minimum variance frontier, covariance matrix | Multi-asset |

---

## 1. Strategies for Creating α (Alpha)

Alpha represents excess returns generated by our signal strategies. We create alpha through three primary approaches:

### 1.1 Multi-Timeframe Trend Analysis

**Implementation**: [`bot/signals_enhanced.py`](file:///Users/akshat/Documents/GitHub/TradingBot/bot/signals_enhanced.py)

Our trend analysis operates across three timeframes to identify high-probability directional moves:

- **Long-term trend (24h)**: Establishes overall market direction
- **Short-term trend (4h)**: Confirms momentum alignment
- **Entry timing (1h)**: Identifies precise entry points

**Key Components**:
```python
# Moving average slope analysis
ma_slope = (ma[-1] - ma[-20]) / ma[-20]

# Pattern recognition
higher_highs = recent_highs.max() > older_highs.max()
lower_lows = recent_lows.min() < older_lows.min()

# Trend strength calculation (0-1 scale)
strength = min(abs(ma_slope) * 20, 1.0)
```

**Alpha Generation**: Captures sustained directional moves by requiring alignment across multiple timeframes, filtering out noise and false signals.

### 1.2 Volatility Expansion Breakouts

**Implementation**: [`bot/signals_volatility_expansion.py`](file:///Users/akshat/Documents/GitHub/TradingBot/bot/signals_volatility_expansion.py)

Identifies explosive moves following periods of consolidation using Bollinger Band squeeze detection:

**Entry Signals**:
- Bollinger Band squeeze detected (band width < 2%)
- Volume spike (>150% of 20-period average)
- RSI crosses above/below 50 for directional confirmation
- Price breaks upper/lower Bollinger Band

**Market Regime Detection**:
```python
# MACD for trend direction
macd_signal = "bullish" if macd > signal_line else "bearish"

# Bollinger squeeze for volatility regime
is_squeeze = band_width_pct < squeeze_threshold

# Regime classification
regime = "ranging" if is_squeeze else "trending"
```

**Alpha Generation**: Captures the explosive volatility expansion that typically follows consolidation periods, entering at the start of major moves.

### 1.3 Mean Reversion with Divergence

**Implementation**: [`bot/signals_volatility_expansion.py`](file:///Users/akshat/Documents/GitHub/TradingBot/bot/signals_volatility_expansion.py) - `generate_mean_reversion_signal()`

Exploits overextended price moves in ranging markets:

**Entry Conditions**:
- RSI oversold (<30 for longs) or overbought (>70 for shorts)
- Price touches Bollinger Band extremes
- RSI divergence confirmation (price vs momentum)
- ADX < 25 (ranging market confirmation)
- Price above 50 EMA on daily (trend filter for longs)

**Quality Scoring**:
```python
quality = 0.60  # Base quality
quality += 0.20 if rsi < 20 else 0.15  # Very oversold bonus
quality += 0.10 if price <= lower_band else 0.05  # Band touch bonus
quality += 0.10 if has_divergence else 0.0  # Divergence bonus
quality += 0.05 if rsi_recovering else 0.0  # RSI recovery bonus
```

**Alpha Generation**: Captures reversal profits from extreme price deviations, with quality filters to avoid catching falling knives.

### 1.4 Support/Resistance Breakouts

**Implementation**: [`bot/signals_enhanced.py`](file:///Users/akshat/Documents/GitHub/TradingBot/bot/signals_enhanced.py) - `find_support_resistance_levels()`

Identifies key price levels and trades confirmed breakouts:

**Level Identification**:
- Rolling window peak/trough detection (1-hour windows)
- Multi-touch confirmation (≥2 touches required)
- Level clustering to identify strong zones

**Breakout Confirmation**:
- Price moves >2% beyond level
- Volume surge ≥2x average
- False breakout risk assessment

**Alpha Generation**: Exploits institutional order flow around key technical levels where large positions trigger momentum cascades.

### 1.5 Technical Indicators

**Implementation**: [`bot/indicators.py`](file:///Users/akshat/Documents/GitHub/TradingBot/bot/indicators.py)

Our alpha strategies leverage optimized technical indicators:

| Indicator | Purpose | Parameters |
|-----------|---------|------------|
| **RSI** | Momentum & divergence | 14-period |
| **MACD** | Trend direction | 3-10-16 (crypto-optimized) |
| **Bollinger Bands** | Volatility & extremes | 20-period, 1.5-2.0 std dev |
| **ATR** | Volatility measurement | 14-period |
| **ADX** | Trend strength | 14-period |
| **EMA** | Trend filtering | 50-period |

---

## 2. Sharpe Maximization

The Sharpe ratio component focuses on optimizing risk-adjusted returns through signal quality and timing.

### 2.1 Rolling Sharpe Ratio Strategy

**Implementation**: [`bot/signals_sharpe_optimized.py`](file:///Users/akshat/Documents/GitHub/TradingBot/bot/signals_sharpe_optimized.py)

Directly optimizes for Sharpe ratio by computing rolling risk-adjusted returns:

```python
# Log returns calculation
log_returns = np.log(prices / prices.shift(1))

# Rolling Sharpe (no annualization for short timeframes)
rolling_mean = log_returns.rolling(window).mean()
rolling_std = log_returns.rolling(window).std()
sharpe_ratio = rolling_mean / rolling_std
```

**Entry Conditions**:
- Sharpe ratio > 0.05 (minimum threshold)
- Momentum > 1% over 12-hour lookback
- Quality score > 0.5 (combination of Sharpe and momentum)

**Sharpe Optimization**: Selects assets with the best risk-adjusted momentum, avoiding high-volatility chop.

### 2.2 Signal Quality Scoring

**Implementation**: All signal generators implement quality scoring from 0-1

Quality factors considered:

| Factor | Weight | Description |
|--------|--------|-------------|
| **Trend Alignment** | 0.3 | Multi-timeframe trend agreement |
| **Volume Confirmation** | 0.25 | Volume vs average ratio |
| **Breakout Strength** | 0.25 | Level significance and false risk |
| **Momentum Quality** | 0.2 | RSI, divergence, momentum filters |

**Example from Enhanced Signals**:
```python
# Trend alignment (0.5-0.9 depending on alignment)
if long == short == entry: quality_factors.append(0.9)
elif long == short: quality_factors.append(0.7)
else: quality_factors.append(0.5)

# Volume confirmation
if volume_ratio > 1.5: quality_factors.append(0.9)
elif volume_ratio > 1.3: quality_factors.append(0.8)
else: quality_factors.append(0.6)

entry_quality = sum(quality_factors) / len(quality_factors)
```

**Sharpe Optimization**: Only high-quality signals (>0.55) generate trades, improving win rate and reducing drawdowns.

### 2.3 Signal Ranking System

**Implementation**: All signal generators include `rank_signals()` methods

Signals are ranked by combined score:
```python
score = signal_strength * 0.6 + entry_quality * 0.4

# Bonus for trend-aligned trades
if trend_aligned:
    score *= 1.2
```

**Sharpe Optimization**: Capital is allocated to the highest-scoring opportunities, maximizing expected risk-adjusted returns.

### 2.4 Entry Timing Optimization

**Multi-timeframe confluence**: Requires alignment across 1h-4h-24h timeframes

**Batch Entry System**:
- **Breakouts**: 2 batches with 10% spacing (aggressive entry)
- **Mean Reversion**: 2-4 batches depending on RSI extremity
  - RSI < 20: 4 batches (highest conviction)
  - RSI 20-25: 3 batches
  - RSI 25-30: 2 batches

**Sharpe Optimization**: Staged entries reduce timing risk and improve average entry price, smoothing returns.

### 2.5 Portfolio Optimization: Tangency Portfolio (Minimum Variance Frontier)

**Implementation**: [`bot/signals.py`](file:///Users/akshat/Documents/GitHub/TradingBot/bot/signals.py) - `TangencyPortfolioSignals`

We implement Modern Portfolio Theory (MPT) to construct the optimal portfolio on the **efficient frontier** that maximizes the Sharpe ratio.

**Tangency Portfolio Theory**:

The tangency portfolio is the point on the minimum variance frontier that maximizes the Sharpe ratio. It represents the optimal combination of risky assets for a given risk-free rate.

```python
# Compute tangency portfolio weights (max Sharpe long-only)
# Mathematical formulation: w = Σ^(-1) × μ
# Where: Σ = covariance matrix, μ = expected returns vector

# Get expected returns
expected_returns = np.array([features[p]["rolling_mean"] for p in selected_pairs])

# Covariance matrix estimation
variances = np.array([features[p]["rolling_std"]**2 for p in selected_pairs])
cov_matrix = np.diag(variances)  # Simplified: diagonal covariance

# Compute inverse covariance matrix
inv_cov = np.linalg.inv(cov_matrix)

# Tangency portfolio weights (unnormalized)
weights = inv_cov @ expected_returns

# Long-only constraint (no shorting)
weights = np.maximum(weights, 0)

# Normalize to sum to 1
weights = weights / weights.sum()
```

**Portfolio Construction Process**:

1. **Asset Universe Selection**: Top N liquid pairs (sorted by liquidity score)
2. **Expected Return Estimation**: Rolling mean returns from historical data
3. **Covariance Estimation**: Rolling variance for each asset (simplified diagonal matrix)
4. **Optimization**: Solve for weights that maximize Sharpe ratio subject to long-only constraint
5. **Normalization**: Scale weights to sum to 1 (fully invested portfolio)

**Efficient Frontier Context**:

```
Expected Return (μ)
     ^
     |           * Tangency Portfolio (Max Sharpe)
     |         *   
     |       *       Efficient Frontier
     |     *       
     |   *          
     | * Minimum Variance Portfolio
     +-------------------------> Risk (σ)
```

The tangency portfolio lies on the efficient frontier at the point where a line from the risk-free rate is tangent to the frontier - this maximizes risk-adjusted returns.

**Sharpe Optimization Benefits**:
- **Diversification**: Spreads risk across multiple uncorrelated assets
- **Variance Minimization**: Reduces portfolio volatility through correlation benefits
- **Sharpe Maximization**: Optimal risk-adjusted return allocation
- **Dynamic Rebalancing**: Weights adjust as expected returns and volatilities change

**Practical Implementation**:
- Mode selection: `python run.py --mode tangency`
- Asset universe: Top 10 liquid pairs with positive expected returns
- Rebalancing frequency: Every trade cycle (typically hourly)
- Fallback: Equal weighting if covariance matrix is singular

### 2.6 Machine Learning Pattern Recognition

**Implementation**: [`bot/indicators.py`](file:///Users/akshat/Documents/GitHub/TradingBot/bot/indicators.py)

While we don't use traditional ML models (neural networks, random forests), we implement sophisticated **algorithmic pattern recognition** techniques that leverage ML-inspired feature engineering and pattern detection:

#### 2.6.1 RSI Divergence Detection

**Algorithm**: Peak/trough matching with momentum divergence identification

```python
def detect_rsi_divergence(prices, rsi, lookback=20):
    # 1. Feature Extraction: Identify local extrema
    for i in range(2, len(prices) - 2):
        if is_local_peak(prices[i]):
            price_highs.append((i, prices[i]))
        if is_local_trough(prices[i]):
            price_lows.append((i, prices[i]))
    
    # 2. Pattern Matching: Bullish divergence
    # Price makes lower low, RSI makes higher low
    if (price_low2 < price_low1) and (rsi_low2 > rsi_low1):
        return 'bullish_divergence'
    
    # 3. Pattern Matching: Bearish divergence  
    # Price makes higher high, RSI makes lower high
    if (price_high2 > price_high1) and (rsi_high2 < rsi_high1):
        return 'bearish_divergence'
```

**ML-Inspired Techniques**:
- **Feature extraction**: Automated peak/trough detection
- **Pattern classification**: Bullish vs bearish divergence labeling
- **Temporal alignment**: Matching price and RSI extrema within tolerance window
- **Binary classification**: Signal vs no signal decision

#### 2.6.2 Candlestick Pattern Recognition

**Bullish Engulfing Pattern**:

```python
def detect_bullish_engulfing(df, lookback=2):
    # Feature engineering from OHLC data
    prev_body = abs(prev_candle['close'] - prev_candle['open'])
    curr_body = abs(curr_candle['close'] - curr_candle['open'])
    
    # Pattern recognition rules (ML decision tree equivalent)
    if (curr_candle['close'] > curr_candle['open'] and  # Bullish candle
        curr_candle['open'] < prev_candle['close'] and   # Opens below prev close
        curr_candle['close'] > prev_candle['open'] and   # Closes above prev open
        curr_body > prev_body * 1.2):                    # Significant engulfing
        return True
```

**Hammer Pattern Detection**:

```python
def detect_hammer_pattern(df, lookback=3):
    # Feature extraction
    body = abs(candle['close'] - candle['open'])
    lower_wick = min(candle['open'], candle['close']) - candle['low']
    upper_wick = candle['high'] - max(candle['open'], candle['close'])
    
    # Decision rules (equivalent to decision tree classifier)
    hammer_conditions = [
        lower_wick > (body * 2),        # Long lower wick
        upper_wick < (body * 0.3),      # Small upper wick
        close_position > 0.9            # Close near high
    ]
    
    return all(hammer_conditions)
```

**ML-Equivalent Techniques**:

| ML Technique | Our Implementation | Purpose |
|--------------|-------------------|---------|
| **Feature Engineering** | OHLC → body/wick ratios | Extract meaningful features |
| **Decision Trees** | Rule-based pattern matching | Binary classification (pattern exists?) |
| **Supervised Learning** | Historical pattern validation | Pattern effectiveness scoring |
| **Classification** | Signal labeling (buy/sell/neutral) | Trade signal generation |
| **Ensemble Methods** | Multi-pattern confirmation | Combine multiple signals |

#### 2.6.3 Multi-Pattern Ensemble Approach

**Implementation**: Mean reversion strategy combines multiple patterns:

```python
# Ensemble pattern recognition (similar to ensemble ML)
confirmation_signals = []

# Signal 1: RSI divergence (primary)
if detect_rsi_divergence(prices, rsi) == 'bullish_divergence':
    confirmation_signals.append('divergence')

# Signal 2: Candlestick patterns (secondary)
if detect_bullish_engulfing(four_hour_data):
    confirmation_signals.append('engulfing')
    
if detect_hammer_pattern(four_hour_data):
    confirmation_signals.append('hammer')

# Ensemble decision: Multiple confirmations increase quality score
quality += 0.10 if 'divergence' in confirmation_signals else 0.0
quality += 0.05 if 'engulfing' in confirmation_signals else 0.0
quality += 0.05 if 'hammer' in confirmation_signals else 0.0
```

**Sharpe Optimization Through ML Patterns**:
- **Higher Win Rate**: Patterns filter high-probability setups
- **Reduced False Signals**: Multi-pattern confirmation reduces noise
- **Adaptive Quality Scoring**: Pattern combinations adjust signal strength
- **Risk-Adjusted Entries**: Only trade when multiple patterns align

**Why Algorithmic > Traditional ML**:
1. **Interpretability**: Clear logic vs black-box neural networks
2. **Data Efficiency**: Works with limited historical data
3. **Computational Speed**: Real-time pattern detection
4. **Domain Knowledge**: Incorporates proven technical analysis principles
5. **Robustness**: Less prone to overfitting than complex ML models

---

## 3. Risk Management (Increase/Decrease Risk)

Risk management dynamically adjusts position sizing to maintain consistent risk exposure across varying market conditions.

### 3.1 Volatility-Adjusted Position Sizing

**Implementation**: [`bot/risk.py`](file:///Users/akshat/Documents/GitHub/TradingBot/bot/risk.py) - `calculate_position_size()`

Position size is **inversely proportional to volatility** to maintain consistent risk:

```python
# Base position sizing
base_position = max_position_pct * total_equity

# Volatility adjustment (inverse relationship)
volatility_adjustment = 1.0 / (1.0 + volatility * volatility_scalar)

# Final position size
position_size = base_position * volatility_adjustment

# Apply minimum order constraints
amount = position_size / price
```

**Risk Management Principle**: 
- **High volatility** → Smaller positions → **Decrease risk**
- **Low volatility** → Larger positions → **Increase risk**
- Total risk exposure remains constant

### 3.2 ATR-Based Stop Loss

**Implementation**: [`bot/risk.py`](file:///Users/akshat/Documents/GitHub/TradingBot/bot/risk.py) - `calculate_atr_stop_loss()`

Dynamic stop losses adapt to current market volatility:

```python
# ATR calculation (14-period)
atr_value = calculate_atr(high, low, close, period=14)

# Stop loss distance
stop_distance = atr_value * atr_multiplier  # Default 2.0x

# For longs
stop_loss = entry_price - stop_distance

# For shorts
stop_loss = entry_price + stop_distance
```

**Parameters**:
- **Breakout strategy**: 2.0x ATR (balanced stops)
- **Mean reversion**: 2.0x ATR

**Risk Management**: Wider stops in volatile markets prevent premature exits; tighter stops in calm markets protect capital.

### 3.3 ATR-Based Position Sizing

**Implementation**: [`bot/risk.py`](file:///Users/akshat/Documents/GitHub/TradingBot/bot/risk.py) - `calculate_position_size_with_atr()`

Alternative sizing method using fixed risk per trade:

```python
# Risk amount (1.5% of equity)
risk_amount = total_equity * risk_per_trade_pct

# Stop loss distance
stop_distance = atr_value * atr_multiplier

# Position size = Risk / Stop Distance
position = risk_amount / stop_distance
```

**Risk Management**: Each trade risks a fixed percentage (1.5%) regardless of volatility, ensuring consistent risk exposure.

### 3.4 Maximum Position Limits

**Implementation**: [`bot/risk.py`](file:///Users/akshat/Documents/GitHub/TradingBot/bot/risk.py)

Hard caps prevent over-concentration:

```python
max_position_pct = 0.4  # 40% of total equity maximum
```

**Quality-Based Scaling**:
```python
# Scale position size by signal quality
adjusted_position = base_position * signal_quality

# Never exceed maximum
final_position = min(adjusted_position, max_position)
```

**Risk Management**: 
- **High-quality signals** → Larger positions (up to 40%) → **Increase risk**
- **Lower-quality signals** → Smaller positions → **Decrease risk**

### 3.5 Batch Entry Risk Management

**Implementation**: Signal generators include batch entry price arrays

**Breakout Strategy** (2 batches):
```python
batch_entries = [
    current_price,  # Batch 1: immediate entry
    current_price * 1.10  # Batch 2: 10% higher (breakout continuation)
]
```

**Mean Reversion Strategy** (2-4 batches):
```python
batch_entries = [
    current_price,  # Batch 1: immediate entry
    current_price * 0.90,  # Batch 2: 10% lower (dip buying)
    current_price * 0.80,  # Batch 3: 20% lower
    current_price * 0.70   # Batch 4: 30% lower (max 4 batches)
]
```

**Risk Management**: 
- Distributes capital across multiple entry points
- Improves average entry price
- **Decreases risk** by reducing timing variance

### 3.6 Profit Targets

**Breakout Strategy**:
- Take profit: +15% (lowered from +25% for achievability)

**Mean Reversion Strategy**:
- Take profit: +25% (return to mean expectation)

**Risk-Reward Ratios**:
- Breakout: ~5:1 with 2% ATR stops
- Mean reversion: ~10:1 with 2.5% ATR stops

**Risk Management**: Asymmetric risk-reward ratios allow for lower win rates while maintaining positive expectancy.

### 3.7 Risk Validation

**Implementation**: [`bot/risk.py`](file:///Users/akshat/Documents/GitHub/TradingBot/bot/risk.py) - `validate_order()`

Pre-trade validation ensures risk constraints are met:

```python
# Check minimum order size
order_value = amount * price
if order_value < exchange_info.min_order_value:
    return False, "Below minimum order"

# Check available balance
if side == "buy":
    required = amount * price
    if balance.get("USD", 0) < required:
        return False, "Insufficient USD balance"
```

**Risk Management**: Prevents invalid orders that could disrupt strategy execution or violate exchange rules.

---

## Installation & Usage

### Prerequisites

- Python 3.10+
- Roostoo API credentials
- Horus API for market data (optional)

### Quick Start

```bash
# Clone repository
git clone https://github.com/yourusername/TradingBot.git
cd TradingBot

# Install dependencies
pip install -r requirements.txt

# Configure API credentials
cp env.template .env
nano .env  # Add your API keys

# Run backtest
python backtest_volatility_expansion.py

# Start live trading
python run_volatility.py --mode volatility
```

### Configuration

Edit `.env` file with your credentials:
```bash
ROOSTOO_API_KEY=your_api_key
ROOSTOO_API_SECRET=your_api_secret
HORUS_API_KEY=your_horus_key  # Optional for data
```

### Backtesting

Test strategies on historical data:

```bash
# Volatility expansion strategy
python backtest_volatility_expansion.py

# Sharpe optimized strategy
python backtest_sharpe_optimized.py

# Enhanced breakout strategy
python backtest.py --mode enhanced
```

---

## Architecture

### Core Components

```
TradingBot/
├── bot/                              # Core trading logic
│   ├── signals_enhanced.py           # Multi-timeframe breakout strategy
│   ├── signals_volatility_expansion.py  # Volatility expansion + mean reversion
│   ├── signals_sharpe_optimized.py   # Rolling Sharpe ratio strategy
│   ├── risk.py                       # Position sizing and risk management
│   ├── indicators.py                 # Technical indicator calculations
│   ├── engine.py                     # Trading execution engine
│   ├── datastore.py                  # Market data persistence
│   ├── config.py                     # Configuration management
│   └── roostoo.py / roostoo_v3.py   # Exchange API clients
├── backtest*.py                      # Backtesting scripts
├── run*.py                           # Live trading scripts
├── data/                             # Historical price data (CSV)
└── scripts/                          # Deployment utilities
```

### Strategy Selection

The bot supports multiple strategy modes:

```python
# Enhanced mode (default)
python run.py --mode enhanced

# Volatility expansion mode
python run_volatility.py

# Sharpe optimized mode
python run.py --mode sharpe
```

### Data Flow

1. **Data Collection**: Minute bars from Horus API → `data/*.csv`
2. **Signal Generation**: Price data → Signal generators → Trading signals
3. **Risk Management**: Signals → Position sizer → Order parameters
4. **Execution**: Orders → Roostoo API → Fills
5. **State Management**: Positions/PnL → `data/state.json`

---

## Performance Metrics

The bot optimizes for the competition scoring function:

```python
Competition Score = 0.4 × Sortino + 0.3 × Sharpe + 0.3 × Calmar
```

Where:
- **Sortino Ratio**: Downside risk-adjusted returns
- **Sharpe Ratio**: Total risk-adjusted returns  
- **Calmar Ratio**: Annualized return / Max drawdown

---

## Formula Breakdown: E[r] = α + sharpe × risk

### How Components Work Together

1. **Alpha (α)** - Generated by:
   - Multi-timeframe trend analysis
   - Volatility expansion breakouts
   - Mean reversion with divergence
   - Support/resistance breakouts
   
2. **Sharpe** - Optimized through:
   - Rolling Sharpe ratio strategy
   - Signal quality scoring (0.55+ threshold)
   - Signal ranking and selection
   - Multi-timeframe entry timing
   - Tangency portfolio optimization (minimum variance frontier)
   - ML pattern recognition (divergence, candlestick patterns)
   
3. **Risk** - Managed via:
   - Volatility-inverse position sizing
   - ATR-based dynamic stops
   - Quality-scaled position sizing
   - Batch entry distribution
   - 40% maximum position limit

### Example Return Calculation

For a typical trade:
- **α**: +3% from volatility expansion breakout
- **sharpe**: 1.5 (high-quality signal)
- **risk**: 40% position size

**Expected Return**: 3% + (1.5 × 40%) = **3% + 0.6% = 3.6% per trade**

With proper risk management, multiple trades compound to generate consistent risk-adjusted returns.

---

## License

MIT License - See [LICENSE](file:///Users/akshat/Documents/GitHub/TradingBot/LICENSE) file

---

## Support

For questions or issues:
1. Review strategy documentation in this README
2. Check code comments in `bot/` modules
3. Analyze backtest results for strategy validation